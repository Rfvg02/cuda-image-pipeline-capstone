#pragma once
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <vector>
#include <sys/stat.h>

#ifdef _WIN32
  #include <direct.h>
  #define MKDIR(path) _mkdir(path)
#else
  #include <unistd.h>
  #define MKDIR(path) mkdir(path, 0755)
#endif

inline void ensure_dir(const std::string& path) {
    // intenta crear; si ya existe, no pasa nada
    MKDIR(path.c_str());
}

inline void write_pgm(const std::string& filename, const unsigned char* img, int w, int h) {
    FILE* f = fopen(filename.c_str(), "wb");
    if (!f) { fprintf(stderr, "Error: cannot open %s\n", filename.c_str()); return; }
    // P5 = binario, comentario opcional, w h, maxval
    fprintf(f, "P5\n# generated by CUDA pipeline\n%d %d\n255\n", w, h);
    fwrite(img, 1, (size_t)w*h, f);
    fclose(f);
}

// Genera una imagen sintética en escala de grises: gradiente + patrón senoidal
inline void synth_image(std::vector<unsigned char>& img, int w, int h, int idx=0) {
    img.resize((size_t)w*h);
    for (int y=0; y<h; ++y) {
        for (int x=0; x<w; ++x) {
            float gx = (float)x / (w-1);
            float gy = (float)y / (h-1);
            float v  = 0.6f*gx + 0.4f*gy;
            // variación por índice para “muchas imágenes”
            float ripple = 0.5f*(sinf(0.1f*(x+idx*7)) + cosf(0.07f*(y+idx*5)));
            float vv = v + 0.25f*ripple;
            int   p = (int)(255.0f * (vv*0.5f + 0.5f));
            if (p<0) p=0; if (p>255) p=255;
            img[(size_t)y*w + x] = (unsigned char)p;
        }
    }
}
